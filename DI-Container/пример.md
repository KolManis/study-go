
## Без DI:

```go
// Плохо: сервис сам создает свою зависимость
type UserService struct {
    db *Database
}

func NewUserService() *UserService {
    return &UserService{
        db: &Database{connection: "localhost"}, // Жёсткая привязка!
    }
}

// Тестировать невозможно - всегда будет реальная БД!

```

## С DI-контейнером:
```go
// Хорошо: зависимости "инжектятся" извне
container.RegisterType("DB", func() interface{} {
    return &Database{connection: "localhost"}
})

container.RegisterType("UserService", func() interface{} {
    db, _ := container.Resolve("DB")
    return &UserService{db: db.(*Database)}
})

// В тестах можем подменить:
container.RegisterType("DB", func() interface{} {
    return &MockDatabase{} // Подмена на мок!
})
```
## Веб-приложение

```go
package main

import (
	"net/http"
)

// Сервисы
type Database struct{ connection string }
type Logger struct{ level string }
type Config struct{ appName string }

type UserService struct {
	db     *Database
	logger *Logger
	config *Config
}

type AuthService struct {
	db     *Database
	logger *Logger
}

func main() {
	container := NewContainer()

	// 1. КОНФИГУРАЦИЯ (в одном месте!)
	container.RegisterType("Config", func() interface{} {
		return &Config{appName: "MyApp"}
	})

	container.RegisterType("Logger", func() interface{} {
		return &Logger{level: "debug"}
	})

	container.RegisterType("DB", func() interface{} {
		return &Database{connection: "user:pass@localhost/db"}
	})

	container.RegisterType("UserService", func() interface{} {
		db, _ := container.Resolve("DB")
		logger, _ := container.Resolve("Logger")
		config, _ := container.Resolve("Config")
		return &UserService{
			db:     db.(*Database),
			logger: logger.(*Logger),
			config: config.(*Config),
		}
	})

	container.RegisterType("AuthService", func() interface{} {
		db, _ := container.Resolve("DB")
		logger, _ := container.Resolve("Logger")
		return &AuthService{
			db:     db.(*Database),
			logger: logger.(*Logger),
		}
	})

	// 2. HTTP ХЕНДЛЕРЫ (чистая бизнес-логика)
	http.HandleFunc("/register", func(w http.ResponseWriter, r *http.Request) {
		userService, _ := container.Resolve("UserService")
		// Используем userService...
	})

	http.HandleFunc("/login", func(w http.ResponseWriter, r *http.Request) {
		authService, _ := container.Resolve("AuthService")
		// Используем authService...
	})

	http.ListenAndServe(":8080", nil)
}
```

хзхзхз